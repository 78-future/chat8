# 隐写术算法改进说明

## 改进概述

本次改进将隐写术算法从单通道存储升级为RGB三通道存储，显著提升了图像的信息存储容量。

## 技术细节

### 改进前（旧算法）
- **存储方式**: 仅使用蓝色(B)通道的最低有效位(LSB)
- **存储容量**: 每个像素存储 1 bit
- **总容量**: 图像像素数 × 1 bit

### 改进后（新算法）
- **存储方式**: 同时使用红色(R)、绿色(G)、蓝色(B)三个通道的最低有效位
- **存储容量**: 每个像素存储 3 bits
- **总容量**: 图像像素数 × 3 bits

## 容量提升效果

| 图像尺寸 | 像素数 | 旧算法容量 | 新算法容量 | 提升倍数 |
|---------|--------|-----------|-----------|----------|
| 50×50   | 2,500  | 2,500 bits (~308 字符) | 7,500 bits (~933 字符) | **3.0倍** |
| 100×100 | 10,000 | 10,000 bits (~1,246 字符) | 30,000 bits (~3,746 字符) | **3.0倍** |
| 200×200 | 40,000 | 40,000 bits (~4,996 字符) | 120,000 bits (~14,996 字符) | **3.0倍** |

## 算法实现细节

### 数据嵌入过程

1. **数据准备**:
   - 将文本消息转换为二进制
   - 添加32位长度头（用于标识消息长度）
   - 总数据 = 32位长度 + 消息二进制数据

2. **像素计算**:
   - 所需像素数 = ⌈总bit数 / 3⌉
   - 每个像素存储3个bit（RGB各1位）

3. **嵌入策略**:
   ```
   对于每个像素(R, G, B):
   - R通道LSB存储第1个bit
   - G通道LSB存储第2个bit  
   - B通道LSB存储第3个bit
   ```

### 数据提取过程

1. **长度提取**:
   - 从前⌈32/3⌉=11个像素中提取32位长度信息
   - 按RGB顺序读取LSB位

2. **消息提取**:
   - 根据提取的长度，继续读取相应数量的bit
   - 跳过前32个bit（长度头），提取实际消息内容

3. **数据重构**:
   - 将二进制数据转换回UTF-8文本

## 兼容性说明

- ✅ **向前兼容**: 新算法可以正确处理各种文本编码（UTF-8）
- ✅ **密码保护**: 保持原有的密码保护机制
- ✅ **错误检测**: 增强了容量检查和错误处理
- ❌ **向后兼容**: 旧算法嵌入的图像无法被新算法正确提取

## 测试验证

通过 `test_steganography_rgb.py` 测试脚本验证了以下功能：

- ✅ 英文消息嵌入/提取
- ✅ 中文消息嵌入/提取  
- ✅ Unicode字符（包括emoji）嵌入/提取
- ✅ 长消息处理
- ✅ 错误密码检测
- ✅ 容量限制检查

## 性能影响

- **嵌入速度**: 基本无变化（仍然是O(n)复杂度）
- **提取速度**: 基本无变化
- **图像质量**: 视觉上无差异（仍然只修改LSB）
- **存储效率**: **提升300%**

## 使用示例

```python
from services.steganography import embed, extract

# 嵌入消息
embed('input.png', '这是一个测试消息', 'my_password', 'output.png')

# 提取消息
message = extract('output.png', 'my_password')
print(message)  # 输出: 这是一个测试消息
```

## 总结

这次改进将隐写术的存储容量提升了3倍，使得在相同尺寸的图像中可以隐藏更多的信息，同时保持了算法的安全性和可靠性。对于用户而言，这意味着可以在更小的图像中隐藏更长的消息，或者在相同的图像中隐藏更丰富的内容。